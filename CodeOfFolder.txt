# Ordnerstruktur

CronoHash
├── .gitignore
├── CMakeLists.txt
├── CronoHash.cpp
├── CronoHash.sln
├── CronoHash.vcxproj
├── CronoHash.vcxproj.filters
├── CronoHash.vcxproj.user
├── FileScanner.py
├── LICENSE.txt
├── README.md
├── WHITEPAPER.md
├── .vs
│   ├── cmake.db
│   ├── CronoHash
│   │   ├── FileContentIndex
│   │   │   ├── 06b43d72-c157-4985-9468-763eeea28784.vsidx
│   │   │   ├── 087a4acd-c2dc-492f-a762-78bb8d1b1eb9.vsidx
│   │   │   ├── 30b4a9df-facd-4df1-b6dd-22c8059b32a1.vsidx
│   │   │   ├── 31a25704-0f99-45c9-a942-0952745bac2a.vsidx
│   │   │   ├── f6362401-313c-48c8-93f9-22d4a6f9a71e.vsidx
│   │   ├── v17
│   │   │   ├── .suo
│   │   │   ├── Browse.VC.db
│   │   │   ├── Browse.VC.db-shm
│   │   │   ├── Browse.VC.db-wal
│   │   │   ├── Browse.VC.opendb
│   │   │   ├── DocumentLayout.backup.json
│   │   │   ├── DocumentLayout.json
│   │   │   ├── Solution.VC.db
│   │   │   ├── ipch
│   │   │   │   ├── AutoPCH
│   │   │   │   │   ├── 241fb7b6eebff151
│   │   │   │   │   │   ├── CRONOHASHTESTS.ipch
│   │   │   │   │   ├── 2cc96f7082de66fb
│   │   │   │   │   │   ├── CRONO_UTILS.ipch
│   │   │   │   │   ├── 34dee2cf2c10513f
│   │   │   │   │   │   ├── CRONO_QUANTUM.ipch
│   │   │   │   │   ├── 4802a7c075467968
│   │   │   │   │   │   ├── VCTMP37612_335705.CRONO_UTILS.00000000.ipch
│   │   │   │   │   ├── 6c29116d7f36fe9
│   │   │   │   │   │   ├── CRONO_MATH.ipch
│   │   │   │   │   ├── 87a9b36ea7308c00
│   │   │   │   │   │   ├── CRONO_HASH.ipch
│   │   │   │   │   ├── 8f1fafc1a052de47
│   │   │   │   │   │   ├── CRONO_HASH.ipch
│   │   │   │   │   ├── 8fc402217d92d25a
│   │   │   │   │   │   ├── CRONO_MATH.ipch
│   │   │   │   │   ├── 903a38257a7e2bc7
│   │   │   │   │   │   ├── VCTMP37612_543174.CRONOHASH.00000000.ipch
│   │   │   │   │   ├── 9783e81425e9c5fc
│   │   │   │   │   │   ├── CRONO_QUANTUM.ipch
│   │   │   │   │   ├── b8f225a905d8bc17
│   │   │   │   │   │   ├── CRONOHASH.ipch
│   │   │   │   │   ├── e1ee3d9e66bc0eb0
│   │   │   │   │   │   ├── CRONO_UTILS.ipch
├── CronoHash
├── include
│   ├── crono_hash.h
│   ├── crono_math.h
│   ├── crono_quantum.h
│   ├── crono_utils.h
├── src
│   ├── crono_hash.cpp
│   ├── crono_math.cpp
│   ├── crono_quantum.cpp
│   ├── crono_utils.cpp
├── tests
│   ├── CronoHashTests.cpp

# Inhalte der Code-Dateien

# CMakeLists.txt - E:\Users\final\source\repos\CronoHash\CMakeLists.txt
# Fehler beim Lesen der Datei: 'utf-8' codec can't decode byte 0xdc in position 214: invalid continuation byte

# CronoHash.cpp - E:\Users\final\source\repos\CronoHash\CronoHash.cpp
﻿#include <iostream>
#include <cstring>
#include <string>
#include <cstdlib>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <limits>
#include "include/crono_hash.h"
#include <oqs/sha3.h> // Für die Generierung eines sicheren Strings

// Verhindert Konflikte mit den Windows-Makros min/max
#define NOMINMAX
#ifdef _WIN32
#include <windows.h>
#endif

// Sprachunterstützung: Enum und globale Variable
enum class Language { EN, DE };
static Language currentLanguage = Language::DE; // Standard: Deutsch

// Setzt die Position und Größe des Konsolenfensters (x, y, Breite, Höhe)
static void set_console_window(int x, int y, int width, int height) {
#ifdef _WIN32
    HWND consoleWindow = GetConsoleWindow();
    if (consoleWindow) {
        HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
        COORD bufferSize = { 0, 0 }; // Komplett initialisieren
        bufferSize.X = static_cast<SHORT>(width);
        bufferSize.Y = static_cast<SHORT>(height);
        SetConsoleScreenBufferSize(hConsole, bufferSize);
        MoveWindow(consoleWindow, x, y, width, height, TRUE);
    }
#endif
}

// Druckt das ASCII-Logo und Entwicklerdaten (unabhängig von der Sprache)
static void print_logo_and_developer_info() {
    std::cout << R"delim(
 a88888b.                                     dP     dP                    dP       
d8'   `88                                     88     88                    88       
88        88d888b. .d8888b. 88d888b. .d8888b. 88aaaaa88a .d8888b. .d8888b. 88d888b. 
88        88'  `88 88'  `88 88'  `88 88'  `88 88     88  88'  `88 Y8ooooo. 88'  `88 
Y8.   .88 88       88.  .88 88    88 88.  .88 88     88  88.  .88       88 88    88 
 Y88888P' dP       `88888P' dP    dP `88888P' dP     dP  `88888P8 `88888P' dP    dP 
  











                                                                                  
)delim" << std::endl;

    // Entwicklerinfo (initial in Deutsch)
    std::cout << "CronoHash v1.0" << std::endl;
    std::cout << "Entwickelt von Blythex" << std::endl;
    std::cout << "GitHub: https://github.com/BlythexPP" << std::endl;
    std::cout << "Datum: " << __DATE__ << "\n\n";
}

// Neue Funktion: generate_secure_string zur sicheren Generierung eines Input-Strings
static std::string generate_secure_string(size_t length) {
    unsigned char output[32];
    uint64_t seed = static_cast<uint64_t>(std::time(nullptr));
    unsigned char seed_bytes[8] = { 0 }; // Array mit Nullen initialisieren
    for (size_t i = 0; i < 8; i++) {
        seed_bytes[i] = static_cast<unsigned char>((seed >> (8 * i)) & 0xFF);
    }
    OQS_SHA3_shake128(output, 32, seed_bytes, 8);
    std::ostringstream oss;
    size_t bytes_to_use = (length < 32 ? length : 32);
    for (size_t i = 0; i < bytes_to_use; i++) {
        oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(output[i]);
    }
    return oss.str();
}

// Neue Funktion: Sprachwahl vor der interaktiven Eingabe
static Language select_language() {
    int choice = 0;
    std::cout << "Select Language / Sprache wählen:\n";
    std::cout << "1. Deutsch\n";
    std::cout << "2. English\n";
    std::cout << "Your choice / Ihre Wahl: ";
    std::cin >> choice;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    return (choice == 2) ? Language::EN : Language::DE;
}

// Überschriebene Hilfefunktion zur Ausgabe der Kommandozeilenparameter
static void print_usage() {
    if (currentLanguage == Language::DE) {
        std::cout << "Usage: CronoHash [-i input_string] [-d binding_duration_ms] [-m mode] [-b bit_strength]\n";
        std::cout << "  -i : Input-String zum Hashen (Standard: \"CronoHash Prime Core v1\")\n";
        std::cout << "  -d : Temp-Binding-Dauer in Millisekunden (Standard: 0, kein Binding)\n";
        std::cout << "  -m : Mode (FAST, BALANCED, SECURE, ENTROPIC) (Standard: BALANCED)\n";
        std::cout << "  -b : Bitstärke (128, 256, 512, 1024, 2048) (Standard: 256)\n";
        std::cout << "  -h : Zeige diese Hilfemeldung an\n";
    }
    else {
        std::cout << "Usage: CronoHash [-i input_string] [-d binding_duration_ms] [-m mode] [-b bit_strength]\n";
        std::cout << "  -i : Input string to hash (default: \"CronoHash Prime Core v1\")\n";
        std::cout << "  -d : Temp binding duration in milliseconds (default: 0, no binding)\n";
        std::cout << "  -m : Mode (FAST, BALANCED, SECURE, ENTROPIC) (default: BALANCED)\n";
        std::cout << "  -b : Bit strength (128, 256, 512, 1024, 2048) (default: 256)\n";
        std::cout << "  -h : Show this help message\n";
    }
}

// Überschriebene Funktion zur Auswahl der Temp-Binding-Dauer
static double prompt_binding_duration() {
    double duration_ms = 0;
    if (currentLanguage == Language::DE) {
        std::cout << "Wählen Sie die Temp-Binding Option:\n";
        std::cout << "1. Einmaliger Login-Token (500 - 2000 ms)\n";
        std::cout << "2. RAM-only Secrets / Anti-Debug (50 - 200 ms)\n";
        std::cout << "3. Temporärer File-Decryption Key (3000 - 5000 ms)\n";
        std::cout << "4. Forensische Marker (5000 - 10000 ms)\n";
        std::cout << "5. Testing/Debug-Modus (60000 ms)\n";
        std::cout << "6. Custom\n";
        std::cout << "Ihre Wahl (1-6): ";
    }
    else {
        std::cout << "Please choose the Temp-Binding Option:\n";
        std::cout << "1. One-time login token (500 - 2000 ms)\n";
        std::cout << "2. RAM-only secrets / Anti-Debug (50 - 200 ms)\n";
        std::cout << "3. Temporary file-decryption key (3000 - 5000 ms)\n";
        std::cout << "4. Forensic markers (5000 - 10000 ms)\n";
        std::cout << "5. Testing/Debug mode (60000 ms)\n";
        std::cout << "6. Custom\n";
        std::cout << "Your choice (1-6): ";
    }
    int choice;
    std::cin >> choice;
    switch (choice) {
    case 1: duration_ms = 1000; break;
    case 2: duration_ms = 100; break;
    case 3: duration_ms = 4000; break;
    case 4: duration_ms = 7500; break;
    case 5: duration_ms = 60000; break;
    case 6:
        if (currentLanguage == Language::DE) {
            std::cout << "Geben Sie die gewünschte Dauer in Millisekunden ein: ";
        }
        else {
            std::cout << "Enter the desired duration in milliseconds: ";
        }
        std::cin >> duration_ms;
        break;
    default:
        if (currentLanguage == Language::DE)
            std::cout << "Ungültige Auswahl. Standardwert 0 wird verwendet.\n";
        else
            std::cout << "Invalid choice. Default value 0 will be used.\n";
        duration_ms = 0;
    }
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    return duration_ms;
}

// Überschriebene Funktion zur Auswahl des Modes
static CronoHash::CronoMode prompt_mode() {
    if (currentLanguage == Language::DE) {
        std::cout << "Wählen Sie den Mode:\n";
        std::cout << "1. FAST\n";
        std::cout << "2. BALANCED\n";
        std::cout << "3. SECURE\n";
        std::cout << "4. ENTROPIC\n";
        std::cout << "Ihre Wahl (1-4): ";
    }
    else {
        std::cout << "Select the mode:\n";
        std::cout << "1. FAST\n";
        std::cout << "2. BALANCED\n";
        std::cout << "3. SECURE\n";
        std::cout << "4. ENTROPIC\n";
        std::cout << "Your choice (1-4): ";
    }
    int choice;
    std::cin >> choice;
    CronoHash::CronoMode mode = CronoHash::CronoMode::BALANCED;
    switch (choice) {
    case 1: mode = CronoHash::CronoMode::FAST; break;
    case 2: mode = CronoHash::CronoMode::BALANCED; break;
    case 3: mode = CronoHash::CronoMode::SECURE; break;
    case 4: mode = CronoHash::CronoMode::ENTROPIC; break;
    default:
        if (currentLanguage == Language::DE)
            std::cout << "Ungültige Auswahl. Standard BALANCED wird verwendet.\n";
        else
            std::cout << "Invalid choice. Default BALANCED will be used.\n";
        mode = CronoHash::CronoMode::BALANCED;
    }
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    return mode;
}

// Überschriebene Funktion zur Auswahl der Bitstärke
static unsigned int prompt_bit_strength() {
    if (currentLanguage == Language::DE) {
        std::cout << "Wählen Sie die gewünschte Bitstärke:\n";
        std::cout << "1. 128 Bit\n";
        std::cout << "2. 256 Bit\n";
        std::cout << "3. 512 Bit\n";
        std::cout << "4. 1024 Bit\n";
        std::cout << "5. 2048 Bit\n";
        std::cout << "Ihre Wahl (1-5): ";
    }
    else {
        std::cout << "Select the desired bit strength:\n";
        std::cout << "1. 128 Bit\n";
        std::cout << "2. 256 Bit\n";
        std::cout << "3. 512 Bit\n";
        std::cout << "4. 1024 Bit\n";
        std::cout << "5. 2048 Bit\n";
        std::cout << "Your choice (1-5): ";
    }
    int choice;
    std::cin >> choice;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    switch (choice) {
    case 1: return 128;
    case 2: return 256;
    case 3: return 512;
    case 4: return 1024;
    case 5: return 2048;
    default:
        if (currentLanguage == Language::DE)
            std::cout << "Ungültige Auswahl. Standard 256 Bit wird verwendet.\n";
        else
            std::cout << "Invalid choice. Default 256 Bit will be used.\n";
        return 256;
    }
}

int main(int argc, char* argv[]) {
    // Konsole positionieren etc.
    set_console_window(1066, 825, 1805, 873);
    print_logo_and_developer_info();

    // Im interaktiven Modus: Sprachwahl durchführen
    if (argc == 1) {
        currentLanguage = select_language();
    }

    std::string input = "CronoHash Prime Core v1";
    double binding_duration = 0.0;
    CronoHash::CronoMode mode = CronoHash::CronoMode::BALANCED;
    unsigned int bit_strength = 256;
    const size_t MIN_LENGTH = 8;

    // Kommandozeilenparameter verarbeiten
    if (argc > 1) {
        for (int i = 1; i < argc; i++) {
            if (std::strcmp(argv[i], "-i") == 0 && (i + 1) < argc) {
                input = argv[++i];
            }
            else if (std::strcmp(argv[i], "-d") == 0 && (i + 1) < argc) {
                binding_duration = std::atof(argv[++i]);
            }
            else if (std::strcmp(argv[i], "-m") == 0 && (i + 1) < argc) {
                std::string modeStr = argv[++i];
                if (modeStr == "FAST")
                    mode = CronoHash::CronoMode::FAST;
                else if (modeStr == "BALANCED")
                    mode = CronoHash::CronoMode::BALANCED;
                else if (modeStr == "SECURE")
                    mode = CronoHash::CronoMode::SECURE;
                else if (modeStr == "ENTROPIC")
                    mode = CronoHash::CronoMode::ENTROPIC;
                else {
                    if (currentLanguage == Language::DE)
                        std::cout << "Unbekannter Mode. Standard BALANCED wird verwendet.\n";
                    else
                        std::cout << "Unknown mode. Default BALANCED will be used.\n";
                    mode = CronoHash::CronoMode::BALANCED;
                }
            }
            else if (std::strcmp(argv[i], "-b") == 0 && (i + 1) < argc) {
                bit_strength = std::atoi(argv[++i]);
                if (bit_strength != 128 && bit_strength != 256 && bit_strength != 512 &&
                    bit_strength != 1024 && bit_strength != 2048) {
                    if (currentLanguage == Language::DE)
                        std::cout << "Ungültige Bitstärke. Standard 256 Bit wird verwendet.\n";
                    else
                        std::cout << "Invalid bit strength. Default 256 Bit will be used.\n";
                    bit_strength = 256;
                }
            }
            else if (std::strcmp(argv[i], "-h") == 0) {
                print_usage();
                return 0;
            }
            else {
                if (currentLanguage == Language::DE)
                    std::cout << "Ungültiger Parameter.\n";
                else
                    std::cout << "Invalid parameter.\n";
                print_usage();
                return 1;
            }
        }
    }
    else {
        if (currentLanguage == Language::DE)
            std::cout << "Geben Sie den Input-String ein (mindestens " << MIN_LENGTH << " Zeichen): ";
        else
            std::cout << "Please enter the input string (at least " << MIN_LENGTH << " characters): ";
        std::getline(std::cin, input);
        if (input.empty()) {
            if (currentLanguage == Language::DE)
                std::cout << "Kein Input eingegeben. Standardwert wird verwendet.\n";
            else
                std::cout << "No input entered. Default value will be used.\n";
            input = "CronoHash Prime Core v1";
        }
        binding_duration = prompt_binding_duration();
        mode = prompt_mode();
        bit_strength = prompt_bit_strength();
    }

    if (input.length() < MIN_LENGTH) {
        if (currentLanguage == Language::DE)
            std::cout << "Input zu kurz. Generiere sicheren Input-String...\n";
        else
            std::cout << "Input too short. Generating secure input string...\n";
        input = generate_secure_string(MIN_LENGTH);
        if (currentLanguage == Language::DE)
            std::cout << "Generierter Input: " << input << "\n";
        else
            std::cout << "Generated input: " << input << "\n";
    }

    std::string hash = CronoHash::hash(input.c_str(), input.length(), binding_duration, mode, bit_strength);
    if (currentLanguage == Language::DE)
        std::cout << bit_strength << "-Bit Hash: " << hash << std::endl;
    else
        std::cout << bit_strength << "-Bit hash: " << hash << std::endl;

    std::string meta = CronoHash::hash_with_metadata(input.c_str(), input.length(), binding_duration, mode, bit_strength);
    if (currentLanguage == Language::DE)
        std::cout << "Metadaten: " << meta << std::endl;
    else
        std::cout << "Metadata: " << meta << std::endl;

    return 0;
}


# LICENSE.txt - E:\Users\final\source\repos\CronoHash\LICENSE.txt
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


# crono_hash.h - E:\Users\final\source\repos\CronoHash\include\crono_hash.h
#pragma once
#include <string>
#include <cstddef>

namespace CronoHash {

    // Neue Config-Flags für unterschiedliche Hash-Modi
    enum class CronoMode {
        FAST,
        BALANCED,
        SECURE,
        ENTROPIC
    };

    // Liefert den 256-Bit Hash als hexadezimale Zeichenkette (64 Zeichen).
    // binding_duration_ms definiert die Temp-Binding-Dauer in Millisekunden.
    // mode steuert zusätzliche Mix-Runden und Extra-Entropie.
    // Neuer Parameter "bit_strength" (in Bit), z. B. 128, 256, 512, 1024, 2048.
    std::string hash(const char* data, std::size_t length, double binding_duration_ms = 0.0, CronoMode mode = CronoMode::BALANCED, unsigned int bit_strength = 256);

    std::string hash_with_metadata(const char* data, std::size_t length, double binding_duration_ms = 0.0, CronoMode mode = CronoMode::BALANCED, unsigned int bit_strength = 256);
}


# crono_math.h - E:\Users\final\source\repos\CronoHash\include\crono_math.h
#pragma once
#include <cstdint>

namespace CronoMath {
    // SHA256-ähnliche Primzahlen (für die erste Rundendurchläufe)
    extern const uint64_t* PRIMES;
    extern const int NUM_PRIMES;

    // Wendet zuerst den Modulo mit einer Basis-Primzahl an
    uint64_t mod_prime(uint64_t input);
    // Wendet einen zusätzlichen Modulo mit extra Primzahlen an (für 256-Bit)
    uint64_t mod_prime256(uint64_t input, int index);

    // Führt eine endomorphe Transformation durch (nichtlinear, seed-abhängig)
    uint64_t endomorph_transform(uint64_t input, uint64_t seed);
    // Mischt das Input mit konstanten Werten, um eine One-Way-Funktion zu erzeugen
    uint64_t hash_const_mix(uint64_t input);
}


# crono_quantum.h - E:\Users\final\source\repos\CronoHash\include\crono_quantum.h
#pragma once
#include <cstddef>
#include <cstdint>

namespace CronoQuantum {
    // Bestehende Funktion
    uint64_t quantum_mix(uint64_t input, const char* data, std::size_t length);
    // Neue Funktion: Kyber512-Phase
    uint64_t quantum_mix_kyber(uint64_t input, const char* data, std::size_t length);
}


# crono_utils.h - E:\Users\final\source\repos\CronoHash\include\crono_utils.h
# Fehler beim Lesen der Datei: 'utf-8' codec can't decode byte 0x85 in position 122: invalid start byte

# crono_hash.cpp - E:\Users\final\source\repos\CronoHash\src\crono_hash.cpp
﻿#include "../include/crono_hash.h"
#include "../include/crono_utils.h"
#include "../include/crono_math.h"
#include "../include/crono_quantum.h"
#include <sstream>
#include <iomanip>
#include <vector>
#include <chrono>  // Für alternative Zeitquellen

static std::string modeToString(CronoHash::CronoMode mode) {
    using CronoMode = CronoHash::CronoMode;
    switch (mode) {
    case CronoMode::FAST:      return "FAST";
    case CronoMode::BALANCED:  return "BALANCED";
    case CronoMode::SECURE:    return "SECURE";
    case CronoMode::ENTROPIC:  return "ENTROPIC";
    }
    return "UNKNOWN";
}

namespace CronoHash {

    std::string hash(const char* data, std::size_t length, double binding_duration_ms, CronoMode mode, unsigned int bit_strength) {
        // Berechne die Anzahl der 64-Bit-Worte, die benötigt werden:
        unsigned int num_words = bit_strength / 64;
        if (num_words == 0)
            num_words = 1; // Sicherheitshalber

        // Array zur Speicherung – hier verwenden wir einen Vektor
        std::vector<uint64_t> words(num_words);

        // Zeit- und Entropiequellen:
        uint64_t tsc = CronoUtils::get_tsc();
#ifdef _WIN32
        // Unter Windows: Nutze die implementierte Funktion
        uint64_t nano = CronoUtils::get_current_nanotime();
#else
        // Unter Linux (Debian/Ubuntu): Verwende system_clock für die reale Systemzeit
        uint64_t nano = std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
#endif
        // Steady Clock bleibt plattformunabhängig (monotonic)
        uint64_t steady = CronoUtils::get_steady_time();

        // Erzeuge Umgebungsentropie
        uint64_t ram = CronoUtils::ram_fingerprint();
        uint64_t cache = CronoUtils::cache_noise();

        // Initialisierungsrunde: Jeder 64-Bit Block erhält einen Startwert,
        // der aus den Zeit- und Entropiequellen sowie einer Primzahl abgeleitet wird.
        for (unsigned int i = 0; i < num_words; i++) {
            words[i] = tsc ^ (nano << ((i % 8) + 1)) ^ steady ^ ram ^ cache ^ CronoMath::PRIMES[i % CronoMath::NUM_PRIMES];
            words[i] = CronoUtils::mix_entropy(words[i], data, length);
            words[i] = CronoMath::endomorph_transform(words[i], tsc);
            words[i] = CronoMath::hash_const_mix(words[i]);
            words[i] = CronoMath::mod_prime(words[i]);
        }

        // Zweite Mischrunde: Weitere Transformationen unter Einbeziehung von 'nano'
        for (unsigned int i = 0; i < num_words; i++) {
            words[i] = CronoMath::endomorph_transform(words[i], nano);
            words[i] = CronoUtils::mix_entropy(words[i], data, length);
            words[i] = CronoMath::hash_const_mix(words[i]);
            words[i] = CronoMath::mod_prime256(words[i], i % 4);
        }

        // Zusätzliche Runden für SECURE/ENTROPIC-Modus
        if (mode == CronoMode::SECURE || mode == CronoMode::ENTROPIC) {
            for (unsigned int i = 0; i < num_words; i++) {
                words[i] = CronoMath::endomorph_transform(words[i], steady);
                words[i] = CronoUtils::mix_entropy(words[i], data, length);
            }
        }

        // Im ENTROPIC-Modus: Zusätzlicher Memory Walk
        if (mode == CronoMode::ENTROPIC) {
            uint64_t mem_walk = CronoUtils::memory_walk();
            for (unsigned int i = 0; i < num_words; i++) {
                words[i] ^= mem_walk;
            }
        }

        // Adaptive Zeitbindung (Temp Binding)
        if (binding_duration_ms > 0.0) {
            uint64_t binding_factor = CronoUtils::adaptive_binding_factor(binding_duration_ms);
            for (unsigned int i = 0; i < num_words; i++) {
                words[i] ^= binding_factor;
            }
        }

        // GhostSalt-Runde zur weiteren Vermischung
        uint64_t gs = CronoUtils::ghost_salt();
        for (unsigned int i = 0; i < num_words; i++) {
            words[i] ^= gs;
        }

        // Quantum Runden:
        // Erste Runde via SHAKE128
        for (unsigned int i = 0; i < num_words; i++) {
            uint64_t qm = CronoQuantum::quantum_mix(words[i], data, length);
            words[i] ^= qm;
        }
        // Zweite Runde via Kyber512
        for (unsigned int i = 0; i < num_words; i++) {
            uint64_t qm2 = CronoQuantum::quantum_mix_kyber(words[i], data, length);
            words[i] ^= qm2;
        }

        // Ausgabe: Jeder 64-Bit Block wird als 16 Hexadezimalzeichen dargestellt
        std::ostringstream out;
        for (unsigned int i = 0; i < num_words; i++) {
            out << std::hex << std::setw(16) << std::setfill('0') << words[i];
        }
        return out.str();
    }

    std::string hash_with_metadata(const char* data, std::size_t length, double binding_duration_ms, CronoMode mode, unsigned int bit_strength) {
        uint64_t tsc = CronoUtils::get_tsc();
#ifdef _WIN32
        uint64_t nano = CronoUtils::get_current_nanotime();
#else
        uint64_t nano = std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
#endif
        uint64_t binding_factor = 0;
        if (binding_duration_ms > 0.0) {
            binding_factor = CronoUtils::adaptive_binding_factor(binding_duration_ms);
        }
        std::string hash_result = hash(data, length, binding_duration_ms, mode, bit_strength);
        std::ostringstream json;
        json << "{\n";
        json << "  \"hash\": \"" << hash_result << "\",\n";
        json << "  \"tsc\": " << tsc << ",\n";
        json << "  \"nano\": " << nano << ",\n";
        json << "  \"binding_factor\": \"0x" << std::hex << binding_factor << std::dec << "\",\n";
        json << "  \"mode\": \"" << modeToString(mode) << "\",\n";
        json << "  \"bit_strength\": " << bit_strength << "\n";
        json << "}";
        return json.str();
    }
}


# crono_math.cpp - E:\Users\final\source\repos\CronoHash\src\crono_math.cpp
﻿#include "../include/crono_math.h"
#include "../include/crono_utils.h"  // notwendig für CronoUtils::rotate_left
#include <algorithm>
#include <array>
#include <random>
#include <chrono>

namespace CronoMath {

    // 64 hochwertige 64-Bit-Primzahlen als statisches Array
    const std::array<uint64_t, 64> STATIC_PRIMES = {
        0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
        0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
        0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
        0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
        0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
        0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
        0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
        0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
        0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
        0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
        0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
        0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
        0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
        0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
        0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
        0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
        0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
        0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
        0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
        0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
        0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
        0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
        0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
        0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
        0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
        0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
        0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
        0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
        0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
        0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL
    };

    // Erzeuge einen modifizierbaren Vektor, der zur Laufzeit zufällig permutiert wird.
    std::array<uint64_t, 64> randomizedPrimes = STATIC_PRIMES;

    // Einmalige Initialisierung der zufälligen Permutation
    static void initializeRandomizedPrimes() {
        unsigned seed = static_cast<unsigned>(std::chrono::high_resolution_clock::now().time_since_epoch().count());
        std::shuffle(randomizedPrimes.begin(), randomizedPrimes.end(), std::default_random_engine(seed));
    }

    // Statische Initialisierung: Wird einmal beim Laden des Moduls ausgeführt
    static bool isInitialized = []() {
        initializeRandomizedPrimes();
        return true;
        }();

    // Definition der externen Variablen aus dem Header:
    const uint64_t* PRIMES = randomizedPrimes.data();
    const int NUM_PRIMES = static_cast<int>(randomizedPrimes.size());

    // Die restlichen Funktionen:
    uint64_t mod_prime(uint64_t input) {
        size_t index = input % randomizedPrimes.size();
        uint64_t divisor = randomizedPrimes[index];
        if (divisor == 0) {
            // Fehlerbehandlung oder Fallback-Wert
            divisor = 1; // Damit nicht durch 0 geteilt wird
        }
        return input % divisor;
    }


    uint64_t mod_prime256(uint64_t input, int index) {
        static const uint64_t EXTRA_PRIMES[4] = {
            0xCbbb9d5dc1059ed8ULL, 0x629a292a367cd507ULL,
            0x9159015a3070dd17ULL, 0x152fecd8f70e5939ULL
        };
        return input % EXTRA_PRIMES[index];
    }

    static const uint64_t SECP_CONSTANT = 0xD1B54A32D192ED03ULL;

    uint64_t endomorph_transform(uint64_t input, uint64_t seed) {
        input ^= seed;
        input *= SECP_CONSTANT;
        input = CronoUtils::rotate_left(input, 13);
        input ^= seed;
        input *= SECP_CONSTANT;
        return input;
    }

    uint64_t hash_const_mix(uint64_t input) {
        return input ^ 0xA5A5A5A5A5A5A5A5ULL ^ 0xDEADBEEF1337BEEFULL;
    }
} // namespace CronoMath


# crono_quantum.cpp - E:\Users\final\source\repos\CronoHash\src\crono_quantum.cpp
﻿#include "../include/crono_quantum.h"
#include <oqs/sha3.h>   // SHA3 Header von liboqs
#include <oqs/oqs.h>    // Allgemeine OQS-Funktionen
#include <oqs/kem.h>    // Für KEM-Funktionen und -Längen
#include <cstring>
#include <vector>

namespace CronoQuantum {

    uint64_t quantum_mix(uint64_t input, const char* data, std::size_t length) {
        size_t total_len = sizeof(input) + length;
        std::vector<unsigned char> buffer(total_len);

        for (size_t i = 0; i < sizeof(input); i++) {
            buffer[i] = static_cast<unsigned char>((input >> (8 * i)) & 0xFF);
        }
        std::memcpy(buffer.data() + sizeof(input), data, length);

        unsigned char output[32];
        OQS_SHA3_shake128(output, 32, buffer.data(), total_len);

        uint64_t qm = 0;
        for (size_t i = 0; i < 8; i++) {
            qm |= static_cast<uint64_t>(output[i]) << (8 * i);
        }
        return qm;
    }

    uint64_t quantum_mix_kyber(uint64_t input, const char* data, std::size_t length) {
        // Erstelle einen kombinierten Puffer wie in quantum_mix
        size_t total_len = sizeof(input) + length;
        std::vector<unsigned char> buffer(total_len);

        for (size_t i = 0; i < sizeof(input); i++) {
            buffer[i] = static_cast<unsigned char>((input >> (8 * i)) & 0xFF);
        }
        std::memcpy(buffer.data() + sizeof(input), data, length);

        // Nutze SHAKE128, um einen 64-Byte Seed zu erzeugen
        unsigned char shake_output[64];
        OQS_SHA3_shake128(shake_output, sizeof(shake_output), buffer.data(), total_len);

        // Initialisiere Kyber512 KEM über den Algorithmusnamen
        OQS_KEM* kem = OQS_KEM_new("Kyber512");
        if (kem == nullptr) {
            // Fallback: interpretiere SHAKE-Ergebnis als uint64_t
            uint64_t fallback = 0;
            for (size_t i = 0; i < 8; i++) {
                fallback |= static_cast<uint64_t>(shake_output[i]) << (8 * i);
            }
            return fallback;
        }

        // Verwende die Membervariablen, die die Längen der jeweiligen Puffer enthalten
        size_t pk_len = kem->length_public_key;
        size_t ct_len = kem->length_ciphertext;
        size_t ss_len = kem->length_shared_secret;

        std::vector<unsigned char> public_key(pk_len);
        std::vector<unsigned char> ciphertext(ct_len);
        std::vector<unsigned char> shared_secret(ss_len);

        // Erzeuge einen zufälligen Public Key (nur für den Encaps-Aufruf benötigt)
        OQS_randombytes(public_key.data(), pk_len);

        if (OQS_KEM_encaps(kem, ciphertext.data(), shared_secret.data(), public_key.data()) != OQS_SUCCESS) {
            // Fehlerfall: Fallback
            uint64_t fallback = 0;
            for (size_t i = 0; i < 8; i++) {
                fallback |= static_cast<uint64_t>(shake_output[i]) << (8 * i);
            }
            OQS_KEM_free(kem);
            return fallback;
        }

        // Kombiniere das Shared Secret mit dem SHAKE-Seed via XOR zu einem 64-Bit Wert
        uint64_t qm2 = 0;
        for (size_t i = 0; i < 8 && i < ss_len; i++) {
            qm2 |= static_cast<uint64_t>(shared_secret[i] ^ shake_output[i]) << (8 * i);
        }

        OQS_KEM_free(kem);
        return qm2;
    }
}


# crono_utils.cpp - E:\Users\final\source\repos\CronoHash\src\crono_utils.cpp
﻿#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0A00  // Windows 10 oder höher
#endif

#include "../include/crono_utils.h"
#include "../include/crono_math.h"  // Für endomorph_transform etc.
#include <chrono>
#include <cstdlib>
#include <thread>
#include <vector>
#include <algorithm>
#include <oqs/oqs.h>  // Für OQS_randombytes
#include <sstream>

#ifdef _WIN32
#include <windows.h>
#include <intrin.h>
#include <comdef.h>
#include <Wbemidl.h>
#pragma comment(lib, "wbemuuid.lib")
#else
#include <x86intrin.h>  // Für __rdtsc() auf Linux/Unix
#include <fstream>
#include <sstream>
#include <string>
#endif

namespace CronoUtils {

    // --- Allgemeine Funktionen (plattformübergreifend) ---

    uint64_t get_current_nanotime() {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();
    }

    uint64_t get_tsc() {
        return __rdtsc();
    }

    uint64_t get_steady_time() {
        auto now = std::chrono::steady_clock::now();
        return std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();
    }

    uint64_t rotate_left(uint64_t value, int shift) {
        shift &= 63;
        return (value << shift) | (value >> (64 - shift));
    }

    uint64_t ram_fingerprint() {
        const size_t sample_size = 4096;
        unsigned char* sample = new unsigned char[sample_size];
        OQS_randombytes(sample, sample_size);
        uint64_t result = 0;
        for (size_t i = 0; i < sample_size; i++) {
            result ^= static_cast<uint64_t>(sample[i]) << (i % 8);
        }
        delete[] sample;
        return result;
    }

    uint64_t cache_noise() {
        volatile uint64_t sum = 0;
        int trials = 1000;
        for (int i = 0; i < trials; i++) {
            uint64_t t1 = __rdtsc();
            volatile int x = i * i;
            uint64_t t2 = __rdtsc();
            sum += (t2 - t1);
        }
        return sum ^ (sum << 7);
    }

    uint64_t mix_entropy(uint64_t seed, const char* data, std::size_t length) {
        for (std::size_t i = 0; i < length; i++) {
            seed ^= static_cast<uint64_t>(data[i]) << (i % 8);
            seed = rotate_left(seed, (i % 13) + 1);
            seed ^= ~((seed >> 17) | (seed << 47));
        }
        return seed;
    }

    uint64_t memory_walk() {
        const size_t arr_size = 1024;
        unsigned char buffer[arr_size];
        OQS_randombytes(buffer, arr_size);
        uint64_t walk = 0;
        for (size_t i = 0; i < arr_size; i += 7) {
            walk ^= static_cast<uint64_t>(buffer[i]) << (i % 8);
        }
        return walk;
    }

    static uint64_t thread_binding_factor(double duration_ms) {
        auto start = std::chrono::high_resolution_clock::now();
        uint64_t local_factor = 1;
        while (true) {
            auto now = std::chrono::high_resolution_clock::now();
            double elapsed = std::chrono::duration<double, std::milli>(now - start).count();
            if (elapsed >= duration_ms)
                break;
            uint64_t sample_val = ram_fingerprint() ^ cache_noise();
            local_factor *= (sample_val | 1);
            for (volatile int j = 0; j < 50; j++) {}
            local_factor %= 0xFFFFFFFFFFFFFDULL;
        }
        return local_factor;
    }

    uint64_t adaptive_binding_factor(double duration_ms) {
        unsigned int num_threads = std::thread::hardware_concurrency();
        if (num_threads == 0)
            num_threads = 1;
        std::vector<uint64_t> results(num_threads, 1);
        std::vector<std::thread> threads;
        for (unsigned int i = 0; i < num_threads; i++) {
            threads.emplace_back([&results, i, duration_ms]() {
                results[i] = thread_binding_factor(duration_ms);
                });
        }
        for (auto& t : threads) {
            t.join();
        }
        uint64_t combined = 1;
        for (auto val : results) {
            combined *= (val | 1);
            combined %= 0xFFFFFFFFFFFFFDULL;
        }
        return combined;
    }

    uint64_t ghost_salt() {
        const size_t ghost_size = 2048;
        unsigned char* ghost = new unsigned char[ghost_size];
        OQS_randombytes(ghost, ghost_size);
        uint64_t salt = 0;
        for (size_t i = 0; i < ghost_size; i++) {
            salt ^= static_cast<uint64_t>(ghost[i]) << (i % 8);
        }
        delete[] ghost;
        return salt;
    }

#ifdef _WIN32
    // --- Windows-spezifische Hardware-Fingerprinting-Funktionen ---
    uint64_t get_cpu_id() {
        int cpuInfo[4] = { 0 };
        __cpuid(cpuInfo, 0);
        return (static_cast<uint64_t>(cpuInfo[0]) << 32) | static_cast<uint64_t>(cpuInfo[1]);
    }

    uint64_t tpm_fingerprint() {
        HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
        if (FAILED(hr)) {
            return 0;
        }
        hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, EOAC_NONE, NULL);
        if (FAILED(hr)) {
            CoUninitialize();
            return 0;
        }
        IWbemLocator* pLoc = NULL;
        hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, reinterpret_cast<LPVOID*>(&pLoc));
        if (FAILED(hr)) {
            CoUninitialize();
            return 0;
        }
        IWbemServices* pSvc = NULL;
        hr = pLoc->ConnectServer(_bstr_t(L"ROOT\\CIMV2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
        if (FAILED(hr)) {
            pLoc->Release();
            CoUninitialize();
            return 0;
        }
        hr = CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
            RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
        if (FAILED(hr)) {
            pSvc->Release();
            pLoc->Release();
            CoUninitialize();
            return 0;
        }
        IEnumWbemClassObject* pEnumerator = NULL;
        hr = pSvc->ExecQuery(bstr_t("WQL"),
            bstr_t("SELECT ManufacturerID, ManufacturerVersion FROM Win32_Tpm"),
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL, &pEnumerator);
        uint64_t tpmFP = 0;
        if (SUCCEEDED(hr) && pEnumerator) {
            IWbemClassObject* pclsObj = NULL;
            ULONG uReturn = 0;
            if (pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn) == S_OK && uReturn != 0) {
                VARIANT vtProp;
                VariantInit(&vtProp); // Initialisierung hinzufügen
                hr = pclsObj->Get(L"ManufacturerID", 0, &vtProp, 0, 0);
                if (SUCCEEDED(hr) && vtProp.vt == VT_UI4) {
                    tpmFP ^= vtProp.uintVal;
                }
                VariantClear(&vtProp);

                VariantInit(&vtProp); // Vor erneuter Verwendung erneut initialisieren
                hr = pclsObj->Get(L"ManufacturerVersion", 0, &vtProp, 0, 0);
                if (SUCCEEDED(hr) && (vtProp.vt & VT_ARRAY)) {
                    SAFEARRAY* psa = vtProp.parray;
                    LONG lBound = 0, uBound = 0;
                    SafeArrayGetLBound(psa, 1, &lBound);
                    SafeArrayGetUBound(psa, 1, &uBound);
                    for (LONG i = lBound; i <= uBound; i++) {
                        BYTE byteVal = 0;
                        SafeArrayGetElement(psa, &i, &byteVal);
                        tpmFP ^= static_cast<uint64_t>(byteVal) << (i % 8);
                    }
                }
                VariantClear(&vtProp);
                pclsObj->Release();
            }
            pEnumerator->Release();
        }
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return tpmFP;
    }

    uint64_t os_boot_time() {
        ULONGLONG uptime = GetTickCount64(); // in Millisekunden
        FILETIME ft;
        GetSystemTimeAsFileTime(&ft);
        ULARGE_INTEGER currentTime = { 0 }; // Mit Nullen initialisieren
        currentTime.LowPart = ft.dwLowDateTime;
        currentTime.HighPart = ft.dwHighDateTime;
        uint64_t currentTimeNS = currentTime.QuadPart * 100; // FILETIME in 100-ns-Einheiten -> ns
        uint64_t uptimeNS = uptime * 1000000ULL;             // ms zu ns
        return currentTimeNS - uptimeNS;
    }

    uint64_t bios_serial() {
        HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
        if (FAILED(hr)) {
            return 0;
        }
        hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, EOAC_NONE, NULL);
        if (FAILED(hr)) {
            CoUninitialize();
            return 0;
        }
        IWbemLocator* pLoc = NULL;
        hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, reinterpret_cast<LPVOID*>(&pLoc));
        if (FAILED(hr)) {
            CoUninitialize();
            return 0;
        }
        IWbemServices* pSvc = NULL;
        hr = pLoc->ConnectServer(_bstr_t(L"ROOT\\CIMV2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
        if (FAILED(hr)) {
            pLoc->Release();
            CoUninitialize();
            return 0;
        }
        hr = CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
            RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
        if (FAILED(hr)) {
            pSvc->Release();
            pLoc->Release();
            CoUninitialize();
            return 0;
        }
        IEnumWbemClassObject* pEnumerator = NULL;
        hr = pSvc->ExecQuery(bstr_t("WQL"),
            bstr_t("SELECT SerialNumber FROM Win32_BIOS"),
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL, &pEnumerator);
        uint64_t biosFP = 0;
        IWbemClassObject* pclsObj = NULL;
        ULONG uReturn = 0;
        if (pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn) == S_OK && uReturn != 0) {
            VARIANT vtProp;
            VariantInit(&vtProp);  // Initialisiere die VARIANT
            hr = pclsObj->Get(L"SerialNumber", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR && vtProp.bstrVal != NULL) {
                unsigned long hash = 5381;
                wchar_t* str = vtProp.bstrVal;
                while (*str) {
                    hash = ((hash << 5) + hash) + (*str);
                    str++;
                }
                biosFP = hash;
            }
            VariantClear(&vtProp);
            pclsObj->Release();
        }
        pEnumerator->Release();
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return biosFP;
    }

    std::string generate_system_chain_id() {
        // Windows-Version: Nutzt die oben definierten Funktionen
        uint64_t cpuID = get_cpu_id();
        uint64_t tpmFP = tpm_fingerprint();
        uint64_t bootTime = os_boot_time();
        uint64_t bios = bios_serial();
        uint64_t ramFP = ram_fingerprint();
        uint64_t chain = cpuID ^ tpmFP ^ bootTime ^ bios ^ ramFP;
        for (int i = 0; i < 5; i++) {
            chain = CronoMath::endomorph_transform(chain, get_tsc() ^ chain);
        }
        std::ostringstream oss;
        oss << std::hex << std::setw(16) << std::setfill('0') << chain;
        return oss.str();
    }

#else
    // --- Linux-spezifische Hardware-Fingerprinting-Funktionen ---
    // Diese Implementierungen basieren auf dem Lesen von Systemdateien.
    uint64_t get_cpu_id() {
        std::ifstream cpuinfo("/proc/cpuinfo");
        std::string line;
        uint64_t id = 0;
        while (std::getline(cpuinfo, line)) {
            if (line.find("Serial") != std::string::npos ||
                line.find("model name") != std::string::npos) {
                std::hash<std::string> hash_fn;
                id ^= hash_fn(line);
            }
        }
        return id;
    }

    uint64_t os_boot_time() {
        std::ifstream uptime_file("/proc/uptime");
        std::string uptime_str;
        if (std::getline(uptime_file, uptime_str)) {
            std::istringstream iss(uptime_str);
            double uptime;
            iss >> uptime;
            // Hier wird die System-Uptime (in Sekunden) zurückgegeben.
            // Alternativ könnte man /proc/stat oder systemd-analyze nutzen.
            return static_cast<uint64_t>(uptime * 1e9);
        }
        return 0;
    }

    uint64_t bios_serial() {
        // Versuch, die BIOS-Seriennummer aus DMI-Daten zu lesen
        std::ifstream bios_file("/sys/class/dmi/id/product_uuid");
        std::string bios;
        if (std::getline(bios_file, bios)) {
            std::hash<std::string> hash_fn;
            return hash_fn(bios);
        }
        return 0;
    }

    std::string generate_system_chain_id() {
        // Linux-Version: Nutzt alternative Methoden für Hardware-Fingerprinting
        uint64_t cpuID = get_cpu_id();
        uint64_t bootTime = os_boot_time();
        uint64_t bios = bios_serial();
        uint64_t ramFP = ram_fingerprint();
        uint64_t chain = cpuID ^ bootTime ^ bios ^ ramFP;
        for (int i = 0; i < 5; i++) {
            chain = CronoMath::endomorph_transform(chain, get_tsc() ^ chain);
        }
        std::ostringstream oss;
        oss << std::hex << std::setw(16) << std::setfill('0') << chain;
        return oss.str();
    }
#endif

} // namespace CronoUtils


# CronoHashTests.cpp - E:\Users\final\source\repos\CronoHash\tests\CronoHashTests.cpp
﻿// CronoHashTests.cpp
#include <gtest/gtest.h>
#include "../include/crono_hash.h"
#include <thread>
#include <chrono>
#include <iostream>

// Test: 128-Bit Hash im BALANCED-Modus
TEST(CronoHashTest, Hash128Balanced) {
    std::string input = "TestInput123";
    auto result = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::BALANCED, 128);
    // 128 Bit = 16 Bytes = 32 Hex-Zeichen
    EXPECT_EQ(result.length(), 32);
    std::cout << "[Hash128Balanced] Hash: " << result << std::endl;
}

// Test: 256-Bit Hash im SECURE-Modus mit Zeitbindung
TEST(CronoHashTest, Hash256Secure) {
    std::string input = "AnotherTestInput456";
    auto result = CronoHash::hash(input.c_str(), input.length(), 1000, CronoHash::CronoMode::SECURE, 256);
    // 256 Bit = 32 Bytes = 64 Hex-Zeichen
    EXPECT_EQ(result.length(), 64);
    std::cout << "[Hash256Secure] Hash: " << result << std::endl;
}

// Edge-Case: Minimaler Input (leerer String)
TEST(CronoHashTest, MinimalInput) {
    std::string input = "";
    auto result = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::FAST, 256);
    EXPECT_EQ(result.length(), 64);
    std::cout << "[MinimalInput] Hash: " << result << std::endl;
}

// Test: Zeitgebundene Hashes sollten sich bei gleichem Input unterscheiden
TEST(CronoHashTest, TimeBindingHashDiffers) {
    std::string input = "RepeatableInput";
    auto hash1 = CronoHash::hash(input.c_str(), input.length(), 1000, CronoHash::CronoMode::SECURE, 256);
    std::this_thread::sleep_for(std::chrono::milliseconds(1500));
    auto hash2 = CronoHash::hash(input.c_str(), input.length(), 1000, CronoHash::CronoMode::SECURE, 256);
    EXPECT_NE(hash1, hash2);
    std::cout << "[TimeBindingHashDiffers] Hash1: " << hash1 << "\nHash2: " << hash2 << std::endl;
}

// Test: Ohne Zeitbindung sollten Hashes deterministisch sein
TEST(CronoHashTest, DeterministicNoBinding) {
    std::string input = "StableInput123";
    auto hash1 = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::FAST, 256);
    auto hash2 = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::FAST, 256);
    EXPECT_EQ(hash1, hash2);
    std::cout << "[DeterministicNoBinding] Hash: " << hash1 << std::endl;
}

// Test: Überprüfung der Metadaten-Ausgabe
TEST(CronoHashTest, MetadataCheck) {
    std::string input = "MetadataTest";
    auto metadata = CronoHash::hash_with_metadata(input.c_str(), input.length(), 500, CronoHash::CronoMode::ENTROPIC, 256);
    EXPECT_NE(metadata.find("\"mode\": \"ENTROPIC\""), std::string::npos);
    EXPECT_NE(metadata.find("\"bit_strength\": 256"), std::string::npos);
    std::cout << "[MetadataCheck] Metadata: " << metadata << std::endl;
}

// Test: Überprüfe verschiedene Bitstärken
TEST(CronoHashTest, VaryingBitStrengths) {
    std::string input = "BitStrengthTest";
    for (unsigned int bit = 128; bit <= 2048; bit *= 2) {
        auto hash = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::BALANCED, bit);
        size_t expectedLength = bit / 4; // 1 Hex-Zeichen = 4 Bit
        EXPECT_EQ(hash.length(), expectedLength) << "Fehler bei Bitstärke: " << bit;
        std::cout << "[VaryingBitStrengths] " << bit << "-Bit Hash: " << hash << std::endl;
    }
}

// Test: Überprüfe verschiedene Modi
TEST(CronoHashTest, DifferentModes) {
    std::string input = "ModeTest";
    CronoHash::CronoMode modes[] = { CronoHash::CronoMode::FAST, CronoHash::CronoMode::BALANCED,
                                     CronoHash::CronoMode::SECURE, CronoHash::CronoMode::ENTROPIC };
    for (auto mode : modes) {
        auto hash = CronoHash::hash(input.c_str(), input.length(), 500, mode, 256);
        EXPECT_EQ(hash.length(), 64);
        std::string modeStr;
        switch (mode) {
        case CronoHash::CronoMode::FAST: modeStr = "FAST"; break;
        case CronoHash::CronoMode::BALANCED: modeStr = "BALANCED"; break;
        case CronoHash::CronoMode::SECURE: modeStr = "SECURE"; break;
        case CronoHash::CronoMode::ENTROPIC: modeStr = "ENTROPIC"; break;
        }
        std::cout << "[DifferentModes] Mode " << modeStr << " Hash: " << hash << std::endl;
    }
}



