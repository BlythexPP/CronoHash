# Ordnerstruktur

CronoHash
├── CodeOfFolder.txt
├── CronoHash.cpp
├── CronoHash.sln
├── CronoHash.vcxproj
├── CronoHash.vcxproj.filters
├── CronoHash.vcxproj.user
├── FileScanner.py
├── .vs
│   ├── CronoHash
│   │   ├── FileContentIndex
│   │   │   ├── 67512652-fac1-41d7-a9f0-6577243b5e1f.vsidx
│   │   │   ├── 8d660a28-934b-4402-879a-5a3c11ee94d5.vsidx
│   │   │   ├── 93bfefe8-0594-4ab4-9ab4-12e96de9b45e.vsidx
│   │   │   ├── f6362401-313c-48c8-93f9-22d4a6f9a71e.vsidx
│   │   │   ├── fc6cf78e-02f0-44a9-a05f-f21323a497d3.vsidx
│   │   ├── v17
│   │   │   ├── .suo
│   │   │   ├── Browse.VC.db
│   │   │   ├── Browse.VC.db-shm
│   │   │   ├── Browse.VC.db-wal
│   │   │   ├── Browse.VC.opendb
│   │   │   ├── DocumentLayout.backup.json
│   │   │   ├── DocumentLayout.json
│   │   │   ├── ipch
│   │   │   │   ├── AutoPCH
│   │   │   │   │   ├── 241fb7b6eebff151
│   │   │   │   │   │   ├── CRONOHASHTESTS.ipch
│   │   │   │   │   ├── 2cc96f7082de66fb
│   │   │   │   │   │   ├── CRONO_UTILS.ipch
│   │   │   │   │   ├── 34dee2cf2c10513f
│   │   │   │   │   │   ├── CRONO_QUANTUM.ipch
│   │   │   │   │   ├── 6c29116d7f36fe9
│   │   │   │   │   │   ├── CRONO_MATH.ipch
│   │   │   │   │   ├── 87a9b36ea7308c00
│   │   │   │   │   │   ├── CRONO_HASH.ipch
│   │   │   │   │   ├── 8f1fafc1a052de47
│   │   │   │   │   │   ├── CRONO_HASH.ipch
│   │   │   │   │   ├── 8fc402217d92d25a
│   │   │   │   │   │   ├── CRONO_MATH.ipch
│   │   │   │   │   ├── 9783e81425e9c5fc
│   │   │   │   │   │   ├── CRONO_QUANTUM.ipch
│   │   │   │   │   ├── b8f225a905d8bc17
│   │   │   │   │   │   ├── CRONOHASH.ipch
│   │   │   │   │   ├── e1ee3d9e66bc0eb0
│   │   │   │   │   │   ├── CRONO_UTILS.ipch
├── CronoHash
├── include
│   ├── crono_hash.h
│   ├── crono_math.h
│   ├── crono_quantum.h
│   ├── crono_utils.h
├── src
│   ├── crono_hash.cpp
│   ├── crono_math.cpp
│   ├── crono_quantum.cpp
│   ├── crono_utils.cpp
├── tests
│   ├── CronoHashTests.cpp

# Inhalte der Code-Dateien

# CodeOfFolder.txt - E:\Users\final\source\repos\CronoHash\CodeOfFolder.txt


# CronoHash.cpp - E:\Users\final\source\repos\CronoHash\CronoHash.cpp
﻿#include <iostream>
#include <cstring>
#include <string>
#include <cstdlib>
#include <sstream>
#include <iomanip>
#include <ctime>
#include "include/crono_hash.h"
#include <oqs/sha3.h> // Für die Generierung eines sicheren Strings

// Verhindert Konflikte mit den Windows-Makros min/max
#define NOMINMAX
#ifdef _WIN32
#include <windows.h>
#endif

// Setzt die Position und Größe des Konsolenfensters (x, y, Breite, Höhe)
void set_console_window(int x, int y, int width, int height) {
#ifdef _WIN32
    HWND consoleWindow = GetConsoleWindow();
    if (consoleWindow) {
        HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
        COORD bufferSize;
        bufferSize.X = static_cast<SHORT>(width);
        bufferSize.Y = static_cast<SHORT>(height);
        SetConsoleScreenBufferSize(hConsole, bufferSize);
        MoveWindow(consoleWindow, x, y, width, height, TRUE);
    }
#endif
}


// Druckt das ASCII-Logo und Entwicklerdaten
void print_logo_and_developer_info() {
    std::cout << R"delim(
 a88888b.                                     dP     dP                    dP       
d8'   `88                                     88     88                    88       
88        88d888b. .d8888b. 88d888b. .d8888b. 88aaaaa88a .d8888b. .d8888b. 88d888b. 
88        88'  `88 88'  `88 88'  `88 88'  `88 88     88  88'  `88 Y8ooooo. 88'  `88 
Y8.   .88 88       88.  .88 88    88 88.  .88 88     88  88.  .88       88 88    88 
 Y88888P' dP       `88888P' dP    dP `88888P' dP     dP  `88888P8 `88888P' dP    dP 
                                                                                    
                                                                                                                                                                                                                                   
                                                                                                                                                                         
                                                                                                                                                                         
 








                                                                                                                                                                        
                                                                                                                                                                         
                                                                                                                                                                         
)delim" << std::endl;

    std::cout << "CronoHash v1.0" << std::endl;
    std::cout << "Entwickelt von Blythex" << std::endl;
    std::cout << "GitHub: https://github.com/BlythexPP" << std::endl;
    std::cout << "Datum: " << __DATE__ << "\n\n";
}

// Druckt die Hilfemeldung für Kommandozeilenparameter
void print_usage() {
    std::cout << "Usage: CronoHash [-i input_string] [-d binding_duration_ms] [-m mode]\n";
    std::cout << "  -i : Input string to hash (default: \"CronoHash Prime Core v1\")\n";
    std::cout << "  -d : Temp binding duration in milliseconds (default: 0, no binding)\n";
    std::cout << "  -m : Mode (FAST, BALANCED, SECURE, ENTROPIC) (default: BALANCED)\n";
    std::cout << "  -h : Show this help message\n";
}

// Interaktives Menü zur Auswahl der Temp-Binding-Dauer
double prompt_binding_duration() {
    std::cout << "Wählen Sie die Temp-Binding Option:\n";
    std::cout << "1. Einmaliger Login-Token (500 - 2000 ms)\n";
    std::cout << "2. RAM-only Secrets / Anti-Debug (50 - 200 ms)\n";
    std::cout << "3. Temporärer File-Decryption Key (3000 - 5000 ms)\n";
    std::cout << "4. Forensische Marker (5000 - 10000 ms)\n";
    std::cout << "5. Testing/Debug-Modus (60000 ms)\n";
    std::cout << "6. Custom\n";
    std::cout << "Ihre Wahl (1-6): ";

    int choice;
    std::cin >> choice;
    double duration_ms = 0;
    switch (choice) {
    case 1: duration_ms = 1000; break;
    case 2: duration_ms = 100; break;
    case 3: duration_ms = 4000; break;
    case 4: duration_ms = 7500; break;
    case 5: duration_ms = 60000; break;
    case 6:
        std::cout << "Geben Sie die gewünschte Dauer in Millisekunden ein: ";
        std::cin >> duration_ms;
        break;
    default:
        std::cout << "Ungültige Auswahl. Standardwert 0 wird verwendet.\n";
        duration_ms = 0;
    }
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    return duration_ms;
}

// Interaktives Menü zur Auswahl des Modes
CronoHash::CronoMode prompt_mode() {
    std::cout << "Wählen Sie den Mode:\n";
    std::cout << "1. FAST\n";
    std::cout << "2. BALANCED\n";
    std::cout << "3. SECURE\n";
    std::cout << "4. ENTROPIC\n";
    std::cout << "Ihre Wahl (1-4): ";

    int choice;
    std::cin >> choice;
    CronoHash::CronoMode mode = CronoHash::CronoMode::BALANCED;
    switch (choice) {
    case 1: mode = CronoHash::CronoMode::FAST; break;
    case 2: mode = CronoHash::CronoMode::BALANCED; break;
    case 3: mode = CronoHash::CronoMode::SECURE; break;
    case 4: mode = CronoHash::CronoMode::ENTROPIC; break;
    default:
        std::cout << "Ungültige Auswahl. Standard BALANCED wird verwendet.\n";
        mode = CronoHash::CronoMode::BALANCED;
    }
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    return mode;
}

// Generiert einen sicheren Zufallsstring mithilfe von liboqs SHAKE128.
// Der generierte String wird in Hexadezimaldarstellung zurückgegeben.
std::string generate_secure_string(size_t length) {
    unsigned char output[32];
    uint64_t seed = static_cast<uint64_t>(std::time(nullptr));
    unsigned char seed_bytes[8];
    for (size_t i = 0; i < 8; i++) {
        seed_bytes[i] = static_cast<unsigned char>((seed >> (8 * i)) & 0xFF);
    }
    OQS_SHA3_shake128(output, 32, seed_bytes, 8);
    std::ostringstream oss;
    size_t bytes_to_use = (length < 32 ? length : 32);
    for (size_t i = 0; i < bytes_to_use; i++) {
        oss << std::hex << std::setw(2) << std::setfill('0') << (int)output[i];
    }
    return oss.str();
}

// Neue Hilfsfunktion zur Auswahl der Bitstärke:
unsigned int prompt_bit_strength() {
    std::cout << "Wählen Sie die gewünschte Bitstärke:\n";
    std::cout << "1. 128 Bit\n";
    std::cout << "2. 256 Bit\n";
    std::cout << "3. 512 Bit\n";
    std::cout << "4. 1024 Bit\n";
    std::cout << "5. 2048 Bit\n";
    std::cout << "Ihre Wahl (1-5): ";
    int choice;
    std::cin >> choice;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    switch (choice) {
    case 1: return 128;
    case 2: return 256;
    case 3: return 512;
    case 4: return 1024;
    case 5: return 2048;
    default:
        std::cout << "Ungültige Auswahl. Standard 256 Bit wird verwendet.\n";
        return 256;
    }
}

int main(int argc, char* argv[]) {
    // Konsole positionieren etc.
    set_console_window(1066, 825, 1805, 873);
    print_logo_and_developer_info();

    std::string input = "CronoHash Prime Core v1";
    double binding_duration = 0.0;
    CronoHash::CronoMode mode = CronoHash::CronoMode::BALANCED;
    unsigned int bit_strength = 256;
    const size_t MIN_LENGTH = 8;

    // Kommandozeilenparameter verarbeiten (Ergänzung: "-b" für Bitstärke)
    if (argc > 1) {
        for (int i = 1; i < argc; i++) {
            if (std::strcmp(argv[i], "-i") == 0 && (i + 1) < argc) {
                input = argv[++i];
            }
            else if (std::strcmp(argv[i], "-d") == 0 && (i + 1) < argc) {
                binding_duration = std::atof(argv[++i]);
            }
            else if (std::strcmp(argv[i], "-m") == 0 && (i + 1) < argc) {
                std::string modeStr = argv[++i];
                if (modeStr == "FAST")
                    mode = CronoHash::CronoMode::FAST;
                else if (modeStr == "BALANCED")
                    mode = CronoHash::CronoMode::BALANCED;
                else if (modeStr == "SECURE")
                    mode = CronoHash::CronoMode::SECURE;
                else if (modeStr == "ENTROPIC")
                    mode = CronoHash::CronoMode::ENTROPIC;
                else {
                    std::cout << "Unbekannter Mode. Standard BALANCED wird verwendet.\n";
                    mode = CronoHash::CronoMode::BALANCED;
                }
            }
            else if (std::strcmp(argv[i], "-b") == 0 && (i + 1) < argc) {
                bit_strength = std::atoi(argv[++i]);
                // Validierung: Erlaubt sind 128,256,512,1024,2048
                if (bit_strength != 128 && bit_strength != 256 && bit_strength != 512 &&
                    bit_strength != 1024 && bit_strength != 2048) {
                    std::cout << "Ungültige Bitstärke. Standard 256 Bit wird verwendet.\n";
                    bit_strength = 256;
                }
            }
            else if (std::strcmp(argv[i], "-h") == 0) {
                std::cout << "Usage: CronoHash [-i input_string] [-d binding_duration_ms] [-m mode] [-b bit_strength]\n";
                return 0;
            }
            else {
                std::cout << "Ungültiger Parameter.\n";
                std::cout << "Usage: CronoHash [-i input_string] [-d binding_duration_ms] [-m mode] [-b bit_strength]\n";
                return 1;
            }
        }
    }
    else {
        std::cout << "Geben Sie den Input-String ein (mindestens " << MIN_LENGTH << " Zeichen): ";
        std::getline(std::cin, input);
        if (input.empty()) {
            std::cout << "Kein Input eingegeben. Standardwert wird verwendet.\n";
            input = "CronoHash Prime Core v1";
        }
        binding_duration = prompt_binding_duration();
        mode = prompt_mode();
        bit_strength = prompt_bit_strength();
    }

    if (input.length() < MIN_LENGTH) {
        std::cout << "Input zu kurz. Generiere sicheren Input-String...\n";
        input = generate_secure_string(MIN_LENGTH);
        std::cout << "Generierter Input: " << input << "\n";
    }

    std::string hash = CronoHash::hash(input.c_str(), input.length(), binding_duration, mode, bit_strength);
    std::cout << bit_strength << "-Bit Hash: " << hash << std::endl;
    std::string meta = CronoHash::hash_with_metadata(input.c_str(), input.length(), binding_duration, mode, bit_strength);
    std::cout << "Metadaten: " << meta << std::endl;

    return 0;
}



# crono_hash.h - E:\Users\final\source\repos\CronoHash\include\crono_hash.h
#pragma once
#include <string>
#include <cstddef>

namespace CronoHash {

    // Neue Config-Flags für unterschiedliche Hash-Modi
    enum class CronoMode {
        FAST,
        BALANCED,
        SECURE,
        ENTROPIC
    };

    // Liefert den 256-Bit Hash als hexadezimale Zeichenkette (64 Zeichen).
    // binding_duration_ms definiert die Temp-Binding-Dauer in Millisekunden.
    // mode steuert zusätzliche Mix-Runden und Extra-Entropie.
    // Neuer Parameter "bit_strength" (in Bit), z. B. 128, 256, 512, 1024, 2048.
    std::string hash(const char* data, std::size_t length, double binding_duration_ms = 0.0, CronoMode mode = CronoMode::BALANCED, unsigned int bit_strength = 256);

    std::string hash_with_metadata(const char* data, std::size_t length, double binding_duration_ms = 0.0, CronoMode mode = CronoMode::BALANCED, unsigned int bit_strength = 256);
}


# crono_math.h - E:\Users\final\source\repos\CronoHash\include\crono_math.h
#pragma once
#include <cstdint>

namespace CronoMath {
    // SHA256-ähnliche Primzahlen (für die erste Rundendurchläufe)
    extern const uint64_t* PRIMES;
    extern const int NUM_PRIMES;

    // Wendet zuerst den Modulo mit einer Basis-Primzahl an
    uint64_t mod_prime(uint64_t input);
    // Wendet einen zusätzlichen Modulo mit extra Primzahlen an (für 256-Bit)
    uint64_t mod_prime256(uint64_t input, int index);

    // Führt eine endomorphe Transformation durch (nichtlinear, seed-abhängig)
    uint64_t endomorph_transform(uint64_t input, uint64_t seed);
    // Mischt das Input mit konstanten Werten, um eine One-Way-Funktion zu erzeugen
    uint64_t hash_const_mix(uint64_t input);
}


# crono_quantum.h - E:\Users\final\source\repos\CronoHash\include\crono_quantum.h
#pragma once
#include <cstddef>
#include <cstdint>

namespace CronoQuantum {
    // Bestehende Funktion
    uint64_t quantum_mix(uint64_t input, const char* data, std::size_t length);
    // Neue Funktion: Kyber512-Phase
    uint64_t quantum_mix_kyber(uint64_t input, const char* data, std::size_t length);
}


# crono_utils.h - E:\Users\final\source\repos\CronoHash\include\crono_utils.h
# Fehler beim Lesen der Datei: 'utf-8' codec can't decode byte 0x85 in position 122: invalid start byte

# crono_hash.cpp - E:\Users\final\source\repos\CronoHash\src\crono_hash.cpp
﻿#include "../include/crono_hash.h"
#include "../include/crono_utils.h"
#include "../include/crono_math.h"
#include "../include/crono_quantum.h"
#include <sstream>
#include <iomanip>
#include <vector>    // <-- Hinzugefügt!

static std::string modeToString(CronoHash::CronoMode mode) {
    using CronoMode = CronoHash::CronoMode;
    switch (mode) {
    case CronoMode::FAST:      return "FAST";
    case CronoMode::BALANCED:  return "BALANCED";
    case CronoMode::SECURE:    return "SECURE";
    case CronoMode::ENTROPIC:  return "ENTROPIC";
    }
    return "UNKNOWN";
}

namespace CronoHash {

    std::string hash(const char* data, std::size_t length, double binding_duration_ms, CronoMode mode, unsigned int bit_strength) {
        // Anzahl der 64-Bit-Worte, die wir benötigen:
        unsigned int num_words = bit_strength / 64;
        if (num_words == 0) num_words = 1; // Absicherung

        // Array zur Speicherung – hier nutzen wir einen Vektor
        std::vector<uint64_t> words(num_words);

        // Für jeden Block einen anderen Startwert, z.B. indem wir tsc plus den Index einbeziehen
        uint64_t tsc = CronoUtils::get_tsc();
        uint64_t nano = CronoUtils::get_current_nanotime();
        uint64_t steady = CronoUtils::get_steady_time();
        uint64_t ram = CronoUtils::ram_fingerprint();
        uint64_t cache = CronoUtils::cache_noise();

        // Initialisierung der Worte – analog zur ersten Runde im Originalcode
        for (unsigned int i = 0; i < num_words; i++) {
            words[i] = tsc ^ (nano << ((i % 8) + 1)) ^ steady ^ ram ^ cache ^ CronoMath::PRIMES[i % CronoMath::NUM_PRIMES];
            words[i] = CronoUtils::mix_entropy(words[i], data, length);
            words[i] = CronoMath::endomorph_transform(words[i], tsc);
            words[i] = CronoMath::hash_const_mix(words[i]);
            words[i] = CronoMath::mod_prime(words[i]);
        }

        // Zweite Mischrunde
        for (unsigned int i = 0; i < num_words; i++) {
            words[i] = CronoMath::endomorph_transform(words[i], nano);
            words[i] = CronoUtils::mix_entropy(words[i], data, length);
            words[i] = CronoMath::hash_const_mix(words[i]);
            words[i] = CronoMath::mod_prime256(words[i], i % 4);
        }

        // Weitere Runden für SECURE/ENTROPIC
        if (mode == CronoMode::SECURE || mode == CronoMode::ENTROPIC) {
            for (unsigned int i = 0; i < num_words; i++) {
                words[i] = CronoMath::endomorph_transform(words[i], steady);
                words[i] = CronoUtils::mix_entropy(words[i], data, length);
            }
        }

        // ENTROPIC-Modus: zusätzlicher Memory Walk
        if (mode == CronoMode::ENTROPIC) {
            uint64_t mem_walk = CronoUtils::memory_walk();
            for (unsigned int i = 0; i < num_words; i++) {
                words[i] ^= mem_walk;
            }
        }

        // Adaptive Temp Binding
        if (binding_duration_ms > 0.0) {
            uint64_t binding_factor = CronoUtils::adaptive_binding_factor(binding_duration_ms);
            for (unsigned int i = 0; i < num_words; i++) {
                words[i] ^= binding_factor;
            }
        }

        // GhostSalt-Runde
        uint64_t gs = CronoUtils::ghost_salt();
        for (unsigned int i = 0; i < num_words; i++) {
            words[i] ^= gs;
        }

        // QUANTUM ROUND – erste Stufe via SHAKE128
        for (unsigned int i = 0; i < num_words; i++) {
            uint64_t qm = CronoQuantum::quantum_mix(words[i], data, length);
            words[i] ^= qm;
        }

        // QUANTUM ROUND – zweite Stufe via Kyber512
        for (unsigned int i = 0; i < num_words; i++) {
            uint64_t qm2 = CronoQuantum::quantum_mix_kyber(words[i], data, length);
            words[i] ^= qm2;
        }

        // Ausgabe als Hexadezimalstring – jeder 64-Bit Block wird zu 16 Hex-Zeichen
        std::ostringstream out;
        for (unsigned int i = 0; i < num_words; i++) {
            out << std::hex << std::setw(16) << std::setfill('0') << words[i];
        }
        return out.str();
    }

    std::string hash_with_metadata(const char* data, std::size_t length, double binding_duration_ms, CronoMode mode, unsigned int bit_strength) {
        uint64_t tsc = CronoUtils::get_tsc();
        uint64_t nano = CronoUtils::get_current_nanotime();
        uint64_t binding_factor = 0;
        if (binding_duration_ms > 0.0) {
            binding_factor = CronoUtils::adaptive_binding_factor(binding_duration_ms);
        }
        std::string hash_result = hash(data, length, binding_duration_ms, mode, bit_strength);
        std::ostringstream json;
        json << "{\n";
        json << "  \"hash\": \"" << hash_result << "\",\n";
        json << "  \"tsc\": " << tsc << ",\n";
        json << "  \"nano\": " << nano << ",\n";
        json << "  \"binding_factor\": \"0x" << std::hex << binding_factor << std::dec << "\",\n";
        json << "  \"mode\": \"" << modeToString(mode) << "\",\n";
        json << "  \"bit_strength\": " << bit_strength << "\n";
        json << "}";
        return json.str();
    }
}


# crono_math.cpp - E:\Users\final\source\repos\CronoHash\src\crono_math.cpp
﻿#include "../include/crono_math.h"
#include "../include/crono_utils.h"  // notwendig für CronoUtils::rotate_left
#include <algorithm>
#include <array>
#include <random>
#include <chrono>

namespace CronoMath {

    // 64 hochwertige 64-Bit-Primzahlen als statisches Array
    const std::array<uint64_t, 64> STATIC_PRIMES = {
        0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
        0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
        0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
        0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
        0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
        0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
        0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
        0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
        0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
        0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
        0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
        0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
        0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
        0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
        0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
        0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
        0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
        0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
        0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
        0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
        0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
        0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
        0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
        0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
        0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
        0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
        0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
        0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
        0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
        0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL
    };

    // Erzeuge einen modifizierbaren Vektor, der zur Laufzeit zufällig permutiert wird.
    std::array<uint64_t, 64> randomizedPrimes = STATIC_PRIMES;

    // Einmalige Initialisierung der zufälligen Permutation
    static void initializeRandomizedPrimes() {
        unsigned seed = static_cast<unsigned>(std::chrono::high_resolution_clock::now().time_since_epoch().count());
        std::shuffle(randomizedPrimes.begin(), randomizedPrimes.end(), std::default_random_engine(seed));
    }

    // Statische Initialisierung: Wird einmal beim Laden des Moduls ausgeführt
    static bool isInitialized = []() {
        initializeRandomizedPrimes();
        return true;
        }();

    // Definition der externen Variablen aus dem Header:
    const uint64_t* PRIMES = randomizedPrimes.data();
    const int NUM_PRIMES = static_cast<int>(randomizedPrimes.size());

    // Die restlichen Funktionen:
    uint64_t mod_prime(uint64_t input) {
        size_t index = input % randomizedPrimes.size();
        uint64_t divisor = randomizedPrimes[index];
        if (divisor == 0) {
            // Fehlerbehandlung oder Fallback-Wert
            divisor = 1; // Damit nicht durch 0 geteilt wird
        }
        return input % divisor;
    }


    uint64_t mod_prime256(uint64_t input, int index) {
        static const uint64_t EXTRA_PRIMES[4] = {
            0xCbbb9d5dc1059ed8ULL, 0x629a292a367cd507ULL,
            0x9159015a3070dd17ULL, 0x152fecd8f70e5939ULL
        };
        return input % EXTRA_PRIMES[index];
    }

    static const uint64_t SECP_CONSTANT = 0xD1B54A32D192ED03ULL;

    uint64_t endomorph_transform(uint64_t input, uint64_t seed) {
        input ^= seed;
        input *= SECP_CONSTANT;
        input = CronoUtils::rotate_left(input, 13);
        input ^= seed;
        input *= SECP_CONSTANT;
        return input;
    }

    uint64_t hash_const_mix(uint64_t input) {
        return input ^ 0xA5A5A5A5A5A5A5A5ULL ^ 0xDEADBEEF1337BEEFULL;
    }
} // namespace CronoMath


# crono_quantum.cpp - E:\Users\final\source\repos\CronoHash\src\crono_quantum.cpp
﻿#include "../include/crono_quantum.h"
#include <oqs/sha3.h>   // SHA3 Header von liboqs
#include <oqs/oqs.h>    // Allgemeine OQS-Funktionen
#include <oqs/kem.h>    // Für KEM-Funktionen und -Längen
#include <cstring>

namespace CronoQuantum {

    uint64_t quantum_mix(uint64_t input, const char* data, std::size_t length) {
        size_t total_len = sizeof(input) + length;
        unsigned char* buffer = new unsigned char[total_len];

        for (size_t i = 0; i < sizeof(input); i++) {
            buffer[i] = static_cast<unsigned char>((input >> (8 * i)) & 0xFF);
        }
        memcpy(buffer + sizeof(input), data, length);

        unsigned char output[32];
        OQS_SHA3_shake128(output, 32, buffer, total_len);
        delete[] buffer;

        uint64_t qm = 0;
        for (size_t i = 0; i < 8; i++) {
            qm |= static_cast<uint64_t>(output[i]) << (8 * i);
        }
        return qm;
    }

    uint64_t quantum_mix_kyber(uint64_t input, const char* data, std::size_t length) {
        // Erstelle einen kombinierten Puffer wie in quantum_mix
        size_t total_len = sizeof(input) + length;
        unsigned char* buffer = new unsigned char[total_len];
        for (size_t i = 0; i < sizeof(input); i++) {
            buffer[i] = static_cast<unsigned char>((input >> (8 * i)) & 0xFF);
        }
        memcpy(buffer + sizeof(input), data, length);

        // Nutze SHAKE128, um einen 64-Byte Seed zu erzeugen
        unsigned char shake_output[64];
        OQS_SHA3_shake128(shake_output, sizeof(shake_output), buffer, total_len);
        delete[] buffer;

        // Initialisiere Kyber512 KEM über den Algorithmusnamen
        OQS_KEM* kem = OQS_KEM_new("Kyber512");
        if (kem == nullptr) {
            // Fallback: interpretiere SHAKE-Ergebnis als uint64_t
            uint64_t fallback = 0;
            for (size_t i = 0; i < 8; i++) {
                fallback |= static_cast<uint64_t>(shake_output[i]) << (8 * i);
            }
            return fallback;
        }

        // Verwende die Membervariablen, die die Längen der jeweiligen Puffer enthalten
        size_t pk_len = kem->length_public_key;
        size_t ct_len = kem->length_ciphertext;
        size_t ss_len = kem->length_shared_secret;

        unsigned char* public_key = new unsigned char[pk_len];
        unsigned char* ciphertext = new unsigned char[ct_len];
        unsigned char* shared_secret = new unsigned char[ss_len];

        // Erzeuge einen zufälligen Public Key (nur für den Encaps-Aufruf benötigt)
        OQS_randombytes(public_key, pk_len);

        if (OQS_KEM_encaps(kem, ciphertext, shared_secret, public_key) != OQS_SUCCESS) {
            // Fehlerfall: Fallback
            uint64_t fallback = 0;
            for (size_t i = 0; i < 8; i++) {
                fallback |= static_cast<uint64_t>(shake_output[i]) << (8 * i);
            }
            OQS_KEM_free(kem);
            delete[] public_key;
            delete[] ciphertext;
            delete[] shared_secret;
            return fallback;
        }

        // Kombiniere das Shared Secret mit dem SHAKE-Seed via XOR zu einem 64-Bit Wert
        uint64_t qm2 = 0;
        for (size_t i = 0; i < 8 && i < ss_len; i++) {
            qm2 |= static_cast<uint64_t>(shared_secret[i] ^ shake_output[i]) << (8 * i);
        }

        OQS_KEM_free(kem);
        delete[] public_key;
        delete[] ciphertext;
        delete[] shared_secret;
        return qm2;
    }
}


# crono_utils.cpp - E:\Users\final\source\repos\CronoHash\src\crono_utils.cpp
﻿#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0A00  // Windows 10 oder höher
#endif

#include "../include/crono_utils.h"
#include "../include/crono_math.h"  // Für endomorph_transform etc.
#include <chrono>
#include <cstdlib>
#include <thread>
#include <vector>
#include <algorithm>
#include <oqs/oqs.h>  // Für OQS_randombytes
#include <sstream>

#ifdef _WIN32
#include <windows.h>
#include <intrin.h>
#include <comdef.h>
#include <Wbemidl.h>
#pragma comment(lib, "wbemuuid.lib")
#endif

namespace CronoUtils {

    // --- Bestehende Funktionen (unverändert) ---

    uint64_t get_current_nanotime() {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();
    }

    uint64_t get_tsc() {
        return __rdtsc();
    }

    uint64_t get_steady_time() {
        auto now = std::chrono::steady_clock::now();
        return std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();
    }

    uint64_t rotate_left(uint64_t value, int shift) {
        shift &= 63;
        return (value << shift) | (value >> (64 - shift));
    }

    uint64_t ram_fingerprint() {
        const size_t sample_size = 4096;
        unsigned char* sample = new unsigned char[sample_size];
        OQS_randombytes(sample, sample_size);
        uint64_t result = 0;
        for (size_t i = 0; i < sample_size; i++) {
            result ^= static_cast<uint64_t>(sample[i]) << (i % 8);
        }
        delete[] sample;
        return result;
    }

    uint64_t cache_noise() {
        volatile uint64_t sum = 0;
        int trials = 1000;
        for (int i = 0; i < trials; i++) {
            uint64_t t1 = __rdtsc();
            volatile int x = i * i;
            uint64_t t2 = __rdtsc();
            sum += (t2 - t1);
        }
        return sum ^ (sum << 7);
    }

    uint64_t mix_entropy(uint64_t seed, const char* data, std::size_t length) {
        for (std::size_t i = 0; i < length; i++) {
            seed ^= static_cast<uint64_t>(data[i]) << (i % 8);
            seed = rotate_left(seed, (i % 13) + 1);
            seed ^= ~((seed >> 17) | (seed << 47));
        }
        return seed;
    }

    uint64_t memory_walk() {
        const size_t arr_size = 1024;
        unsigned char buffer[arr_size];
        OQS_randombytes(buffer, arr_size);
        uint64_t walk = 0;
        for (size_t i = 0; i < arr_size; i += 7) {
            walk ^= static_cast<uint64_t>(buffer[i]) << (i % 8);
        }
        return walk;
    }

    static uint64_t thread_binding_factor(double duration_ms) {
        auto start = std::chrono::high_resolution_clock::now();
        uint64_t local_factor = 1;
        while (true) {
            auto now = std::chrono::high_resolution_clock::now();
            double elapsed = std::chrono::duration<double, std::milli>(now - start).count();
            if (elapsed >= duration_ms)
                break;
            uint64_t sample_val = ram_fingerprint() ^ cache_noise();
            local_factor *= (sample_val | 1);
            for (volatile int j = 0; j < 50; j++) {}
            local_factor %= 0xFFFFFFFFFFFFFDULL;
        }
        return local_factor;
    }

    uint64_t adaptive_binding_factor(double duration_ms) {
        unsigned int num_threads = std::thread::hardware_concurrency();
        if (num_threads == 0)
            num_threads = 1;
        std::vector<uint64_t> results(num_threads, 1);
        std::vector<std::thread> threads;
        for (unsigned int i = 0; i < num_threads; i++) {
            threads.emplace_back([&results, i, duration_ms]() {
                results[i] = thread_binding_factor(duration_ms);
                });
        }
        for (auto& t : threads) {
            t.join();
        }
        uint64_t combined = 1;
        for (auto val : results) {
            combined *= (val | 1);
            combined %= 0xFFFFFFFFFFFFFDULL;
        }
        return combined;
    }

    uint64_t ghost_salt() {
        const size_t ghost_size = 2048;
        unsigned char* ghost = new unsigned char[ghost_size];
        OQS_randombytes(ghost, ghost_size);
        uint64_t salt = 0;
        for (size_t i = 0; i < ghost_size; i++) {
            salt ^= static_cast<uint64_t>(ghost[i]) << (i % 8);
        }
        delete[] ghost;
        return salt;
    }

#ifdef _WIN32
    // --- Windows-spezifische Hardware-Fingerprinting-Funktionen ---

    uint64_t get_cpu_id() {
        int cpuInfo[4] = { 0 };
        __cpuid(cpuInfo, 0);
        return (static_cast<uint64_t>(cpuInfo[0]) << 32) | static_cast<uint64_t>(cpuInfo[1]);
    }

    uint64_t tpm_fingerprint() {
        HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
        if (FAILED(hr)) {
            return 0;
        }

        hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, EOAC_NONE, NULL);

        if (FAILED(hr)) {
            CoUninitialize();
            return 0;
        }

        IWbemLocator* pLoc = NULL;
        hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, reinterpret_cast<LPVOID*>(&pLoc));
        if (FAILED(hr)) {
            CoUninitialize();
            return 0;
        }

        IWbemServices* pSvc = NULL;
        hr = pLoc->ConnectServer(_bstr_t(L"ROOT\\CIMV2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
        if (FAILED(hr)) {
            pLoc->Release();
            CoUninitialize();
            return 0;
        }

        hr = CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
            RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
        if (FAILED(hr)) {
            pSvc->Release();
            pLoc->Release();
            CoUninitialize();
            return 0;
        }

        IEnumWbemClassObject* pEnumerator = NULL;
        hr = pSvc->ExecQuery(bstr_t("WQL"),
            bstr_t("SELECT ManufacturerID, ManufacturerVersion FROM Win32_Tpm"),
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL, &pEnumerator);

        uint64_t tpmFP = 0;
        if (SUCCEEDED(hr) && pEnumerator) {
            IWbemClassObject* pclsObj = NULL;
            ULONG uReturn = 0;
            if (pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn) == S_OK && uReturn != 0) {
                VARIANT vtProp;
                hr = pclsObj->Get(L"ManufacturerID", 0, &vtProp, 0, 0);
                if (SUCCEEDED(hr)) {
                    if (vtProp.vt == VT_UI4) {
                        tpmFP ^= vtProp.uintVal;
                    }
                }
                VariantClear(&vtProp);

                hr = pclsObj->Get(L"ManufacturerVersion", 0, &vtProp, 0, 0);
                if (SUCCEEDED(hr) && (vtProp.vt & VT_ARRAY)) {
                    SAFEARRAY* psa = vtProp.parray;
                    LONG lBound = 0, uBound = 0;
                    SafeArrayGetLBound(psa, 1, &lBound);
                    SafeArrayGetUBound(psa, 1, &uBound);
                    for (LONG i = lBound; i <= uBound; i++) {
                        BYTE byteVal = 0;
                        SafeArrayGetElement(psa, &i, &byteVal);
                        tpmFP ^= static_cast<uint64_t>(byteVal) << (i % 8);
                    }
                }
                VariantClear(&vtProp);
                pclsObj->Release();
            }
            pEnumerator->Release();
        }

        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return tpmFP;
    }

    uint64_t os_boot_time() {
        ULONGLONG uptime = GetTickCount64(); // in Millisekunden
        FILETIME ft;
        GetSystemTimeAsFileTime(&ft);
        ULARGE_INTEGER currentTime;
        currentTime.LowPart = ft.dwLowDateTime;
        currentTime.HighPart = ft.dwHighDateTime;
        uint64_t currentTimeNS = currentTime.QuadPart * 100; // FILETIME in 100-ns-Einheiten -> ns
        uint64_t uptimeNS = uptime * 1000000ULL;             // ms zu ns
        return currentTimeNS - uptimeNS;
    }

    uint64_t bios_serial() {
        HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
        if (FAILED(hr)) {
            return 0;
        }

        hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, EOAC_NONE, NULL);

        if (FAILED(hr)) {
            CoUninitialize();
            return 0;
        }

        IWbemLocator* pLoc = NULL;
        hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, reinterpret_cast<LPVOID*>(&pLoc));
        if (FAILED(hr)) {
            CoUninitialize();
            return 0;
        }

        IWbemServices* pSvc = NULL;
        hr = pLoc->ConnectServer(_bstr_t(L"ROOT\\CIMV2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
        if (FAILED(hr)) {
            pLoc->Release();
            CoUninitialize();
            return 0;
        }

        hr = CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
            RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
        if (FAILED(hr)) {
            pSvc->Release();
            pLoc->Release();
            CoUninitialize();
            return 0;
        }

        IEnumWbemClassObject* pEnumerator = NULL;
        hr = pSvc->ExecQuery(bstr_t("WQL"),
            bstr_t("SELECT SerialNumber FROM Win32_BIOS"),
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL, &pEnumerator);

        uint64_t biosFP = 0;
        IWbemClassObject* pclsObj = NULL;
        ULONG uReturn = 0;
        if (pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn) == S_OK && uReturn != 0) {
            VARIANT vtProp;
            VariantInit(&vtProp);  // Initialisiere die VARIANT vor der Verwendung

            hr = pclsObj->Get(L"SerialNumber", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR && vtProp.bstrVal != NULL) {
                unsigned long hash = 5381;
                wchar_t* str = vtProp.bstrVal;
                while (*str) {
                    hash = ((hash << 5) + hash) + (*str);
                    str++;
                }
                biosFP = hash;
            }

            VariantClear(&vtProp);  // Bereinige die VARIANT
            pclsObj->Release();
        }

        pEnumerator->Release();
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();

        return biosFP;
    }

    // Verkettet alle Hardware-Fingerprints (ohne MAC) und mischt sie in 5 Runden mittels endomorph_transform
    std::string generate_system_chain_id() {
        uint64_t cpuID = get_cpu_id();
        uint64_t tpmFP = tpm_fingerprint();
        uint64_t bootTime = os_boot_time();
        uint64_t bios = bios_serial();
        uint64_t ramFP = ram_fingerprint();

        uint64_t chain = cpuID ^ tpmFP ^ bootTime ^ bios ^ ramFP;
        for (int i = 0; i < 5; i++) {
            chain = CronoMath::endomorph_transform(chain, get_tsc() ^ chain);
        }
        std::ostringstream oss;
        oss << std::hex << std::setw(16) << std::setfill('0') << chain;
        return oss.str();
    }

#endif  // _WIN32

} // namespace CronoUtils


# CronoHashTests.cpp - E:\Users\final\source\repos\CronoHash\tests\CronoHashTests.cpp
﻿// CronoHashTests.cpp
#include <gtest/gtest.h>
#include "../include/crono_hash.h"
#include <thread>
#include <chrono>
#include <iostream>

// Test: 128-Bit Hash im BALANCED-Modus
TEST(CronoHashTest, Hash128Balanced) {
    std::string input = "TestInput123";
    auto result = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::BALANCED, 128);
    // 128 Bit = 16 Bytes = 32 Hex-Zeichen
    EXPECT_EQ(result.length(), 32);
    std::cout << "[Hash128Balanced] Hash: " << result << std::endl;
}

// Test: 256-Bit Hash im SECURE-Modus mit Zeitbindung
TEST(CronoHashTest, Hash256Secure) {
    std::string input = "AnotherTestInput456";
    auto result = CronoHash::hash(input.c_str(), input.length(), 1000, CronoHash::CronoMode::SECURE, 256);
    // 256 Bit = 32 Bytes = 64 Hex-Zeichen
    EXPECT_EQ(result.length(), 64);
    std::cout << "[Hash256Secure] Hash: " << result << std::endl;
}

// Edge-Case: Minimaler Input (leerer String)
TEST(CronoHashTest, MinimalInput) {
    std::string input = "";
    auto result = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::FAST, 256);
    EXPECT_EQ(result.length(), 64);
    std::cout << "[MinimalInput] Hash: " << result << std::endl;
}

// Test: Zeitgebundene Hashes sollten sich bei gleichem Input unterscheiden
TEST(CronoHashTest, TimeBindingHashDiffers) {
    std::string input = "RepeatableInput";
    auto hash1 = CronoHash::hash(input.c_str(), input.length(), 1000, CronoHash::CronoMode::SECURE, 256);
    std::this_thread::sleep_for(std::chrono::milliseconds(1500));
    auto hash2 = CronoHash::hash(input.c_str(), input.length(), 1000, CronoHash::CronoMode::SECURE, 256);
    EXPECT_NE(hash1, hash2);
    std::cout << "[TimeBindingHashDiffers] Hash1: " << hash1 << "\nHash2: " << hash2 << std::endl;
}

// Test: Ohne Zeitbindung sollten Hashes deterministisch sein
TEST(CronoHashTest, DeterministicNoBinding) {
    std::string input = "StableInput123";
    auto hash1 = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::FAST, 256);
    auto hash2 = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::FAST, 256);
    EXPECT_EQ(hash1, hash2);
    std::cout << "[DeterministicNoBinding] Hash: " << hash1 << std::endl;
}

// Test: Überprüfung der Metadaten-Ausgabe
TEST(CronoHashTest, MetadataCheck) {
    std::string input = "MetadataTest";
    auto metadata = CronoHash::hash_with_metadata(input.c_str(), input.length(), 500, CronoHash::CronoMode::ENTROPIC, 256);
    EXPECT_NE(metadata.find("\"mode\": \"ENTROPIC\""), std::string::npos);
    EXPECT_NE(metadata.find("\"bit_strength\": 256"), std::string::npos);
    std::cout << "[MetadataCheck] Metadata: " << metadata << std::endl;
}

// Test: Überprüfe verschiedene Bitstärken
TEST(CronoHashTest, VaryingBitStrengths) {
    std::string input = "BitStrengthTest";
    for (unsigned int bit = 128; bit <= 2048; bit *= 2) {
        auto hash = CronoHash::hash(input.c_str(), input.length(), 0, CronoHash::CronoMode::BALANCED, bit);
        size_t expectedLength = bit / 4; // 1 Hex-Zeichen = 4 Bit
        EXPECT_EQ(hash.length(), expectedLength) << "Fehler bei Bitstärke: " << bit;
        std::cout << "[VaryingBitStrengths] " << bit << "-Bit Hash: " << hash << std::endl;
    }
}

// Test: Überprüfe verschiedene Modi
TEST(CronoHashTest, DifferentModes) {
    std::string input = "ModeTest";
    CronoHash::CronoMode modes[] = { CronoHash::CronoMode::FAST, CronoHash::CronoMode::BALANCED,
                                     CronoHash::CronoMode::SECURE, CronoHash::CronoMode::ENTROPIC };
    for (auto mode : modes) {
        auto hash = CronoHash::hash(input.c_str(), input.length(), 500, mode, 256);
        EXPECT_EQ(hash.length(), 64);
        std::string modeStr;
        switch (mode) {
        case CronoHash::CronoMode::FAST: modeStr = "FAST"; break;
        case CronoHash::CronoMode::BALANCED: modeStr = "BALANCED"; break;
        case CronoHash::CronoMode::SECURE: modeStr = "SECURE"; break;
        case CronoHash::CronoMode::ENTROPIC: modeStr = "ENTROPIC"; break;
        }
        std::cout << "[DifferentModes] Mode " << modeStr << " Hash: " << hash << std::endl;
    }
}



